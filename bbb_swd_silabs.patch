commit af5b24910a6f3df3b5bf60718d3632add997779d
Author: Van Petrosyan <v.petrosyan@enviosystems.com>
Date:   Thu Sep 10 16:02:30 2020 +0200

    test: test

diff --git a/configure.ac b/configure.ac
index fb5514ee6..6901424ae 100644
--- a/configure.ac
+++ b/configure.ac
@@ -527,6 +527,10 @@ AC_ARG_ENABLE([remote-bitbang],
   AS_HELP_STRING([--enable-remote-bitbang], [Enable building support for the Remote Bitbang jtag driver]),
   [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
 
+AC_ARG_ENABLE([bbg-swd],
+  AS_HELP_STRING([--enable-bbg-swd], [Enable building support for BBG-SWD.]),
+  [build_bbg_swd=$enableval], [build_bbg_swd=no])
+
 AC_MSG_CHECKING([whether to enable dummy minidriver])
 if test $build_minidriver_dummy = yes; then
   if test $build_minidriver = yes; then
@@ -818,6 +822,14 @@ if test $build_sysfsgpio = yes; then
 else
   AC_DEFINE([BUILD_SYSFSGPIO], [0], [0 if you don't want SysfsGPIO driver.])
 fi
+
+if test $build_bbg_swd = yes; then
+  build_bbg_swd=yes
+  LIBS="$LIBS -lprussdrv"
+  AC_DEFINE([BUILD_BBG_SWD], [1], [1 if you want the BBG-SWD driver.])
+else
+  AC_DEFINE([BUILD_BBG_SWD], [0], [0 if you don't want the BBG-SWD driver.])
+fi
 #-- Deal with MingW/Cygwin FTD2XX issues
 
 if test $is_win32 = yes; then
@@ -1232,6 +1244,7 @@ AM_CONDITIONAL([IS_WIN32], [test $is_win32 = yes])
 AM_CONDITIONAL([IS_DARWIN], [test $is_darwin = yes])
 AM_CONDITIONAL([BITQ], [test $build_bitq = yes])
 AM_CONDITIONAL([CMSIS_DAP], [test $use_hidapi = yes])
+AM_CONDITIONAL([BBG_SWD], [test $build_bbg_swd = yes])
 
 AM_CONDITIONAL([MINIDRIVER], [test $build_minidriver = yes])
 AM_CONDITIONAL([MINIDRIVER_DUMMY], [test $build_minidriver_dummy = yes])
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index c167e8fdf..377b8dcbb 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -21,6 +21,8 @@ NOR_DRIVERS = \
 	cfi.c \
 	dsp5680xx_flash.c \
 	efm32.c \
+	efr32.c \
+	mgm21.c \
 	em357.c \
 	faux.c \
 	fm3.c \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 56a5cb248..5499f4b26 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -33,6 +33,8 @@ extern struct flash_driver avr_flash;
 extern struct flash_driver cfi_flash;
 extern struct flash_driver dsp5680xx_flash;
 extern struct flash_driver efm32_flash;
+extern struct flash_driver efr32_flash;
+extern struct flash_driver mgm21_flash;
 extern struct flash_driver em357_flash;
 extern struct flash_driver faux_flash;
 extern struct flash_driver fm3_flash;
@@ -85,6 +87,8 @@ static struct flash_driver *flash_drivers[] = {
 	&cfi_flash,
 	&dsp5680xx_flash,
 	&efm32_flash,
+	&efr32_flash,
+	&mgm21_flash,
 	&em357_flash,
 	&faux_flash,
 	&fm3_flash,
diff --git a/src/flash/nor/efr32.c b/src/flash/nor/efr32.c
new file mode 100644
index 000000000..c498ff3c8
--- /dev/null
+++ b/src/flash/nor/efr32.c
@@ -0,0 +1,1022 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath@gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 by Andreas Fritiofson                              *
+ *   andreas.fritiofson@gmail.com                                          *
+ *                                                                         *
+ *   Copyright (C) 2013 by Roman Dmitrienko                                *
+ *   me@iamroman.org                                                       *
+ *                                                                         *
+ *   Copyright (C) 2014 Nemui Trinomius                                    *
+ *   nemuisan_kawausogasuki@live.jp                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+#include <target/cortex_m.h>
+
+/* keep family IDs in decimal */
+#define EFR_FAMILY_ID_MIGHTY_GECKO      28
+#define EFR_FAMILY_ID_BLUE_GECKO        20
+#define EFR_FAMILY_ID_MIGHTY_GECKO_21	128
+
+#define EFR32_FLASH_ERASE_TMO           100
+#define EFR32_FLASH_WDATAREADY_TMO      100
+#define EFR32_FLASH_WRITE_TMO           100
+
+/* size in bytes, not words; must fit all Gecko devices */
+#define LOCKBITS_PAGE_SZ                512
+
+#define EFR32_MSC_INFO_BASE             0x0fe00000
+
+#define EFR32_MSC_USER_DATA             EFR32_MSC_INFO_BASE
+#define EFR32_MSC_LOCK_BITS             (EFR32_MSC_INFO_BASE+0x4000)
+#define EFR32_MSC_DEV_INFO              (EFR32_MSC_INFO_BASE+0x8000)
+
+/* PAGE_SIZE is only present in Leopard, Giant and Wonder Gecko MCUs */
+#define EFR32_MSC_DI_PAGE_SIZE          (EFR32_MSC_DEV_INFO+0x1e7)
+#define EFR32_MSC_DI_FLASH_SZ           (EFR32_MSC_DEV_INFO+0x1f8)
+#define EFR32_MSC_DI_RAM_SZ             (EFR32_MSC_DEV_INFO+0x1fa)
+#define EFR32_MSC_DI_PART_NUM           (EFR32_MSC_DEV_INFO+0x1fc)
+#define EFR32_MSC_DI_PART_FAMILY        (EFR32_MSC_DEV_INFO+0x1fe)
+#define EFR32_MSC_DI_PROD_REV           (EFR32_MSC_DEV_INFO+0x1ff)
+
+#define EFR32_MSC_REGBASE               0x400e0000
+#define EFR32_MSC_WRITECTRL             (EFR32_MSC_REGBASE+0x008)
+#define EFR32_MSC_WRITECTRL_WREN_MASK   0x1
+#define EFR32_MSC_WRITECMD              (EFR32_MSC_REGBASE+0x00c)
+#define EFR32_MSC_WRITECMD_LADDRIM_MASK 0x1
+#define EFR32_MSC_WRITECMD_ERASEPAGE_MASK 0x2
+#define EFR32_MSC_WRITECMD_WRITEONCE_MASK 0x8
+#define EFR32_MSC_ADDRB                 (EFR32_MSC_REGBASE+0x010)
+#define EFR32_MSC_WDATA                 (EFR32_MSC_REGBASE+0x018)
+#define EFR32_MSC_STATUS                (EFR32_MSC_REGBASE+0x01c)
+#define EFR32_MSC_STATUS_BUSY_MASK      0x1
+#define EFR32_MSC_STATUS_LOCKED_MASK    0x2
+#define EFR32_MSC_STATUS_INVADDR_MASK   0x4
+#define EFR32_MSC_STATUS_WDATAREADY_MASK 0x8
+#define EFR32_MSC_STATUS_WORDTIMEOUT_MASK 0x10
+#define EFR32_MSC_STATUS_ERASEABORTED_MASK 0x20
+#define EFR32_MSC_LOCK                  (EFR32_MSC_REGBASE+0x040)
+#define EFR32_MSC_LOCK_LOCKKEY          0x1b71
+
+
+struct efr32x_flash_bank {
+	int probed;
+	uint32_t lb_page[LOCKBITS_PAGE_SZ/4];
+};
+
+struct efr32_info {
+	uint16_t flash_sz_kib;
+	uint16_t ram_sz_kib;
+	uint16_t part_num;
+	uint8_t part_family;
+	uint8_t prod_rev;
+	uint16_t page_size;
+};
+
+static int efr32x_write(struct flash_bank *bank, const uint8_t *buffer,
+	uint32_t offset, uint32_t count);
+
+static int efr32x_get_flash_size(struct flash_bank *bank, uint16_t *flash_sz)
+{
+	return target_read_u16(bank->target, EFR32_MSC_DI_FLASH_SZ, flash_sz);
+}
+
+static int efr32x_get_ram_size(struct flash_bank *bank, uint16_t *ram_sz)
+{
+	return target_read_u16(bank->target, EFR32_MSC_DI_RAM_SZ, ram_sz);
+}
+
+static int efr32x_get_part_num(struct flash_bank *bank, uint16_t *pnum)
+{
+	return target_read_u16(bank->target, EFR32_MSC_DI_PART_NUM, pnum);
+}
+
+static int efr32x_get_part_family(struct flash_bank *bank, uint8_t *pfamily)
+{
+	return target_read_u8(bank->target, EFR32_MSC_DI_PART_FAMILY, pfamily);
+}
+
+static int efr32x_get_prod_rev(struct flash_bank *bank, uint8_t *prev)
+{
+	return target_read_u8(bank->target, EFR32_MSC_DI_PROD_REV, prev);
+}
+
+static int efr32x_read_info(struct flash_bank *bank,
+	struct efr32_info *efr32_info)
+{
+	int ret;
+	uint32_t cpuid = 0;
+
+	memset(efr32_info, 0, sizeof(struct efr32_info));
+
+	ret = target_read_u32(bank->target, CPUID, &cpuid);
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (((cpuid >> 4) & 0xfff) == 0xc23) {
+		/* Cortex-M3 device */
+	} else if (((cpuid >> 4) & 0xfff) == 0xc24) {
+		/* Cortex-M4 device (WONDER GECKO) */
+	} else if (((cpuid >> 4) & 0xfff) == 0xc60) {
+		/* Cortex-M0+ device */
+	} else if (((cpuid >> 4) & 0xfff) == 0xd21) {
+    	/* Cortex-M33 device */
+	} else {
+		LOG_ERROR("Target is not Cortex-Mx Device: %d", (cpuid >> 4) & 0xfff);
+		return ERROR_FAIL;
+	}
+
+	ret = efr32x_get_flash_size(bank, &(efr32_info->flash_sz_kib));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_get_ram_size(bank, &(efr32_info->ram_sz_kib));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_get_part_num(bank, &(efr32_info->part_num));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_get_part_family(bank, &(efr32_info->part_family));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_get_prod_rev(bank, &(efr32_info->prod_rev));
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (EFR_FAMILY_ID_BLUE_GECKO == efr32_info->part_family ||
+			EFR_FAMILY_ID_MIGHTY_GECKO == efr32_info->part_family || 
+			EFR_FAMILY_ID_MIGHTY_GECKO_21 == efr32_info->part_family) {
+		uint8_t pg_size = 0;
+		ret = target_read_u8(bank->target, EFR32_MSC_DI_PAGE_SIZE,
+			&pg_size);
+		if (ERROR_OK != ret)
+			return ret;
+
+		efr32_info->page_size = (1 << ((pg_size+10) & 0xff));
+		if ((2048 != efr32_info->page_size) && (512 != efr32_info->page_size)) {
+			LOG_ERROR("Invalid page size %u", efr32_info->page_size);
+			return ERROR_FAIL;
+		}
+	} else {
+		LOG_ERROR("Unknown MCU family %d", efr32_info->part_family);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Helper to create a human friendly string describing a part
+ */
+static int efr32x_decode_info(struct efr32_info *info, char *buf, int buf_size)
+{
+	int printed = 0;
+
+	switch (info->part_family) {
+		case EFR_FAMILY_ID_MIGHTY_GECKO:
+		case EFR_FAMILY_ID_BLUE_GECKO:
+			printed = snprintf(buf, buf_size, "EFR32 ");
+			break;
+		default:
+			printed = snprintf(buf, buf_size, "EFR32 ");
+	}
+
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+	switch (info->part_family) {
+		case EFR_FAMILY_ID_MIGHTY_GECKO:
+			printed = snprintf(buf, buf_size, "Mighty Gecko");
+			break;
+		case EFR_FAMILY_ID_BLUE_GECKO:
+			printed = snprintf(buf, buf_size, "Blue Gecko");
+			break;
+		default:
+			printed = snprintf(buf, buf_size, "Unknown Gecko");
+			break;
+	}
+
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+	printed = snprintf(buf, buf_size, " - Rev: %d", info->prod_rev);
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+	return ERROR_OK;
+}
+
+/* flash bank efr32 <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(efr32x_flash_bank_command)
+{
+	struct efr32x_flash_bank *efr32x_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	efr32x_info = malloc(sizeof(struct efr32x_flash_bank));
+
+	bank->driver_priv = efr32x_info;
+	efr32x_info->probed = 0;
+	memset(efr32x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
+
+	return ERROR_OK;
+}
+
+/* set or reset given bits in a register */
+static int efr32x_set_reg_bits(struct flash_bank *bank, uint32_t reg,
+	uint32_t bitmask, int set)
+{
+	int ret = 0;
+	uint32_t reg_val = 0;
+
+	ret = target_read_u32(bank->target, reg, &reg_val);
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (set)
+		reg_val |= bitmask;
+	else
+		reg_val &= ~bitmask;
+
+	return target_write_u32(bank->target, reg, reg_val);
+}
+
+static int efr32x_set_wren(struct flash_bank *bank, int write_enable)
+{
+	return efr32x_set_reg_bits(bank, EFR32_MSC_WRITECTRL,
+		EFR32_MSC_WRITECTRL_WREN_MASK, write_enable);
+}
+
+static int efr32x_msc_lock(struct flash_bank *bank, int lock)
+{
+	return target_write_u32(bank->target, EFR32_MSC_LOCK,
+		(lock ? 0 : EFR32_MSC_LOCK_LOCKKEY));
+}
+
+static int efr32x_wait_status(struct flash_bank *bank, int timeout,
+	uint32_t wait_mask, int wait_for_set)
+{
+	int ret = 0;
+	uint32_t status = 0;
+
+	while (1) {
+		ret = target_read_u32(bank->target, EFR32_MSC_STATUS, &status);
+		if (ERROR_OK != ret)
+			break;
+
+		LOG_DEBUG("status: 0x%" PRIx32 "", status);
+
+		if (((status & wait_mask) == 0) && (0 == wait_for_set))
+			break;
+		else if (((status & wait_mask) != 0) && wait_for_set)
+			break;
+
+		if (timeout-- <= 0) {
+			LOG_ERROR("timed out waiting for MSC status");
+			return ERROR_FAIL;
+		}
+
+		alive_sleep(1);
+	}
+
+	if (status & EFR32_MSC_STATUS_ERASEABORTED_MASK)
+		LOG_WARNING("page erase was aborted");
+
+	return ret;
+}
+
+static int efr32x_erase_page(struct flash_bank *bank, uint32_t addr)
+{
+	/* this function DOES NOT set WREN; must be set already */
+	/* 1. write address to ADDRB
+	   2. write LADDRIM
+	   3. check status (INVADDR, LOCKED)
+	   4. write ERASEPAGE
+	   5. wait until !STATUS_BUSY
+	 */
+	int ret = 0;
+	uint32_t status = 0;
+
+	LOG_DEBUG("erasing flash page at 0x%08" PRIx32, addr);
+
+	ret = target_write_u32(bank->target, EFR32_MSC_ADDRB, addr);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_set_reg_bits(bank, EFR32_MSC_WRITECMD,
+		EFR32_MSC_WRITECMD_LADDRIM_MASK, 1);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = target_read_u32(bank->target, EFR32_MSC_STATUS, &status);
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_DEBUG("status 0x%" PRIx32, status);
+
+	if (status & EFR32_MSC_STATUS_LOCKED_MASK) {
+		LOG_ERROR("Page is locked");
+		return ERROR_FAIL;
+	} else if (status & EFR32_MSC_STATUS_INVADDR_MASK) {
+		LOG_ERROR("Invalid address 0x%" PRIx32, addr);
+		return ERROR_FAIL;
+	}
+
+	ret = efr32x_set_reg_bits(bank, EFR32_MSC_WRITECMD,
+		EFR32_MSC_WRITECMD_ERASEPAGE_MASK, 1);
+	if (ERROR_OK != ret)
+		return ret;
+
+	return efr32x_wait_status(bank, EFR32_FLASH_ERASE_TMO,
+		EFR32_MSC_STATUS_BUSY_MASK, 0);
+}
+
+static int efr32x_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int i = 0;
+	int ret = 0;
+
+	if (TARGET_HALTED != target->state) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	efr32x_msc_lock(bank, 0);
+	ret = efr32x_set_wren(bank, 1);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to enable MSC write");
+		return ret;
+	}
+
+	for (i = first; i <= last; i++) {
+		ret = efr32x_erase_page(bank, bank->sectors[i].offset);
+		if (ERROR_OK != ret)
+			LOG_ERROR("Failed to erase page %d", i);
+	}
+
+	ret = efr32x_set_wren(bank, 0);
+	efr32x_msc_lock(bank, 1);
+
+	return ret;
+}
+
+static int efr32x_read_lock_data(struct flash_bank *bank)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	struct target *target = bank->target;
+	int i = 0;
+	int data_size = 0;
+	uint32_t *ptr = NULL;
+	int ret = 0;
+
+	assert(bank->num_sectors > 0);
+
+	/* calculate the number of 32-bit words to read (one lock bit per sector) */
+	data_size = (bank->num_sectors + 31) / 32;
+
+	ptr = efr32x_info->lb_page;
+
+	for (i = 0; i < data_size; i++, ptr++) {
+		ret = target_read_u32(target, EFR32_MSC_LOCK_BITS+i*4, ptr);
+		if (ERROR_OK != ret) {
+			LOG_ERROR("Failed to read PLW %d", i);
+			return ret;
+		}
+	}
+
+	/* also, read ULW, DLW and MLW */
+
+	/* ULW, word 126 */
+	ptr = efr32x_info->lb_page + 126;
+	ret = target_read_u32(target, EFR32_MSC_LOCK_BITS+126*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read ULW");
+		return ret;
+	}
+
+	/* DLW, word 127 */
+	ptr = efr32x_info->lb_page + 127;
+	ret = target_read_u32(target, EFR32_MSC_LOCK_BITS+127*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read DLW");
+		return ret;
+	}
+
+	/* MLW, word 125, present in GG and LG */
+	ptr = efr32x_info->lb_page + 125;
+	ret = target_read_u32(target, EFR32_MSC_LOCK_BITS+125*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read MLW");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int efr32x_write_lock_data(struct flash_bank *bank)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	int ret = 0;
+
+	ret = efr32x_erase_page(bank, EFR32_MSC_LOCK_BITS);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to erase LB page");
+		return ret;
+	}
+
+	return efr32x_write(bank, (uint8_t *)efr32x_info->lb_page, EFR32_MSC_LOCK_BITS,
+		LOCKBITS_PAGE_SZ);
+}
+
+static int efr32x_get_page_lock(struct flash_bank *bank, size_t page)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	uint32_t dw = efr32x_info->lb_page[page >> 5];
+	uint32_t mask = 0;
+
+	mask = 1 << (page & 0x1f);
+
+	return (dw & mask) ? 0 : 1;
+}
+
+static int efr32x_set_page_lock(struct flash_bank *bank, size_t page, int set)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	uint32_t *dw = &efr32x_info->lb_page[page >> 5];
+	uint32_t mask = 0;
+
+	mask = 1 << (page & 0x1f);
+
+	if (!set)
+		*dw |= mask;
+	else
+		*dw &= ~mask;
+
+	return ERROR_OK;
+}
+
+static int efr32x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct target *target = bank->target;
+	int i = 0;
+	int ret = 0;
+
+	if (!set) {
+		LOG_ERROR("Erase device data to reset page locks");
+		return ERROR_FAIL;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	for (i = first; i <= last; i++) {
+		ret = efr32x_set_page_lock(bank, i, set);
+		if (ERROR_OK != ret) {
+			LOG_ERROR("Failed to set lock on page %d", i);
+			return ret;
+		}
+	}
+
+	ret = efr32x_write_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to write LB page");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int efr32x_write_block(struct flash_bank *bank, const uint8_t *buf,
+	uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint32_t buffer_size = 16384;
+	struct working_area *write_algorithm;
+	struct working_area *source;
+	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[5];
+	struct armv7m_algorithm armv7m_info;
+	int ret = ERROR_OK;
+
+	/* see contrib/loaders/flash/efr32.S for src */
+	static const uint8_t efr32x_flash_write_code[] = {
+		/* #define EFR32_MSC_WRITECTRL_OFFSET      0x008 */
+		/* #define EFR32_MSC_WRITECMD_OFFSET       0x00c */
+		/* #define EFR32_MSC_ADDRB_OFFSET          0x010 */
+		/* #define EFR32_MSC_WDATA_OFFSET          0x018 */
+		/* #define EFR32_MSC_STATUS_OFFSET         0x01c */
+		/* #define EFR32_MSC_LOCK_OFFSET           0x03c */
+
+			0x15, 0x4e,    /* ldr     r6, =#0x1b71 */
+			0xc6, 0x63,    /* str     r6, [r0, #EFR32_MSC_LOCK_OFFSET] */
+			0x01, 0x26,    /* movs    r6, #1 */
+			0x86, 0x60,    /* str     r6, [r0, #EFR32_MSC_WRITECTRL_OFFSET] */
+
+		/* wait_fifo: */
+			0x16, 0x68,    /* ldr     r6, [r2, #0] */
+			0x00, 0x2e,    /* cmp     r6, #0 */
+			0x22, 0xd0,    /* beq     exit */
+			0x55, 0x68,    /* ldr     r5, [r2, #4] */
+			0xb5, 0x42,    /* cmp     r5, r6 */
+			0xf9, 0xd0,    /* beq     wait_fifo */
+
+			0x04, 0x61,    /* str     r4, [r0, #EFR32_MSC_ADDRB_OFFSET] */
+			0x01, 0x26,    /* movs    r6, #1 */
+			0xc6, 0x60,    /* str     r6, [r0, #EFR32_MSC_WRITECMD_OFFSET] */
+			0xc6, 0x69,    /* ldr     r6, [r0, #EFR32_MSC_STATUS_OFFSET] */
+			0x06, 0x27,    /* movs    r7, #6 */
+			0x3e, 0x42,    /* tst     r6, r7 */
+			0x16, 0xd1,    /* bne     error */
+
+		/* wait_wdataready: */
+			0xc6, 0x69,    /* ldr     r6, [r0, #EFR32_MSC_STATUS_OFFSET] */
+			0x08, 0x27,    /* movs    r7, #8 */
+			0x3e, 0x42,    /* tst     r6, r7 */
+			0xfb, 0xd0,    /* beq     wait_wdataready */
+
+			0x2e, 0x68,    /* ldr     r6, [r5] */
+			0x86, 0x61,    /* str     r6, [r0, #EFR32_MSC_WDATA_OFFSET] */
+			0x08, 0x26,    /* movs    r6, #8 */
+			0xc6, 0x60,    /* str     r6, [r0, #EFR32_MSC_WRITECMD_OFFSET] */
+
+			0x04, 0x35,    /* adds    r5, #4 */
+			0x04, 0x34,    /* adds    r4, #4 */
+
+		/* busy: */
+			0xc6, 0x69,    /* ldr     r6, [r0, #EFR32_MSC_STATUS_OFFSET] */
+			0x01, 0x27,    /* movs    r7, #1 */
+			0x3e, 0x42,    /* tst     r6, r7 */
+			0xfb, 0xd1,    /* bne     busy */
+
+			0x9d, 0x42,    /* cmp     r5, r3 */
+			0x01, 0xd3,    /* bcc     no_wrap */
+			0x15, 0x46,    /* mov     r5, r2 */
+			0x08, 0x35,    /* adds    r5, #8 */
+
+		/* no_wrap: */
+			0x55, 0x60,    /* str     r5, [r2, #4] */
+			0x01, 0x39,    /* subs    r1, r1, #1 */
+			0x00, 0x29,    /* cmp     r1, #0 */
+			0x02, 0xd0,    /* beq     exit */
+			0xdb, 0xe7,    /* b       wait_fifo */
+
+		/* error: */
+			0x00, 0x20,    /* movs    r0, #0 */
+			0x50, 0x60,    /* str     r0, [r2, #4] */
+
+		/* exit: */
+			0x30, 0x46,    /* mov     r0, r6 */
+			0x00, 0xbe,    /* bkpt    #0 */
+
+		/* LOCKKEY */
+			0x71, 0x1b, 0x00, 0x00
+	};
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(efr32x_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	ret = target_write_buffer(target, write_algorithm->address,
+			sizeof(efr32x_flash_write_code), efr32x_flash_write_code);
+	if (ret != ERROR_OK)
+		return ret;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK) {
+		buffer_size /= 2;
+		buffer_size &= ~3UL; /* Make sure it's 4 byte aligned */
+		if (buffer_size <= 256) {
+			/* we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			target_free_working_area(target, write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	}
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (word-32bit) */
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);	/* buffer start */
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);	/* buffer end */
+	init_reg_param(&reg_params[4], "r4", 32, PARAM_IN_OUT);	/* target address */
+
+	buf_set_u32(reg_params[0].value, 0, 32, EFR32_MSC_REGBASE);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+	buf_set_u32(reg_params[2].value, 0, 32, source->address);
+	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
+	buf_set_u32(reg_params[4].value, 0, 32, address);
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARM_MODE_THREAD;
+
+	ret = target_run_flash_async_algorithm(target, buf, count, 4,
+			0, NULL,
+			5, reg_params,
+			source->address, source->size,
+			write_algorithm->address, 0,
+			&armv7m_info);
+
+	if (ret == ERROR_FLASH_OPERATION_FAILED) {
+		LOG_ERROR("flash write failed at address 0x%"PRIx32,
+				buf_get_u32(reg_params[4].value, 0, 32));
+
+		if (buf_get_u32(reg_params[0].value, 0, 32) &
+				EFR32_MSC_STATUS_LOCKED_MASK) {
+			LOG_ERROR("flash memory write protected");
+		}
+
+		if (buf_get_u32(reg_params[0].value, 0, 32) &
+				EFR32_MSC_STATUS_INVADDR_MASK) {
+			LOG_ERROR("invalid flash memory write address");
+		}
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+	destroy_reg_param(&reg_params[4]);
+
+	return ret;
+}
+
+static int efr32x_write_word(struct flash_bank *bank, uint32_t addr,
+	uint32_t val)
+{
+	/* this function DOES NOT set WREN; must be set already */
+	/* 1. write address to ADDRB
+	   2. write LADDRIM
+	   3. check status (INVADDR, LOCKED)
+	   4. wait for WDATAREADY
+	   5. write data to WDATA
+	   6. write WRITECMD_WRITEONCE to WRITECMD
+	   7. wait until !STATUS_BUSY
+	 */
+
+	/* FIXME: EFR32G ref states (7.3.2) that writes should be
+	 * performed twice per dword */
+
+	int ret = 0;
+	uint32_t status = 0;
+
+	/* if not called, GDB errors will be reported during large writes */
+	keep_alive();
+
+	ret = target_write_u32(bank->target, EFR32_MSC_ADDRB, addr);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_set_reg_bits(bank, EFR32_MSC_WRITECMD,
+		EFR32_MSC_WRITECMD_LADDRIM_MASK, 1);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = target_read_u32(bank->target, EFR32_MSC_STATUS, &status);
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_DEBUG("status 0x%" PRIx32, status);
+
+	if (status & EFR32_MSC_STATUS_LOCKED_MASK) {
+		LOG_ERROR("Page is locked");
+		return ERROR_FAIL;
+	} else if (status & EFR32_MSC_STATUS_INVADDR_MASK) {
+		LOG_ERROR("Invalid address 0x%" PRIx32, addr);
+		return ERROR_FAIL;
+	}
+
+	ret = efr32x_wait_status(bank, EFR32_FLASH_WDATAREADY_TMO,
+		EFR32_MSC_STATUS_WDATAREADY_MASK, 1);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Wait for WDATAREADY failed");
+		return ret;
+	}
+
+	ret = target_write_u32(bank->target, EFR32_MSC_WDATA, val);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("WDATA write failed");
+		return ret;
+	}
+
+	ret = target_write_u32(bank->target, EFR32_MSC_WRITECMD,
+		EFR32_MSC_WRITECMD_WRITEONCE_MASK);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("WRITECMD write failed");
+		return ret;
+	}
+
+	ret = efr32x_wait_status(bank, EFR32_FLASH_WRITE_TMO,
+		EFR32_MSC_STATUS_BUSY_MASK, 0);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Wait for BUSY failed");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int efr32x_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint8_t *new_buffer = NULL;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x3) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte "
+			"alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	if (count & 0x3) {
+		uint32_t old_count = count;
+		count = (old_count | 3) + 1;
+		new_buffer = malloc(count);
+		if (new_buffer == NULL) {
+			LOG_ERROR("odd number of bytes to write and no memory "
+				"for padding buffer");
+			return ERROR_FAIL;
+		}
+		LOG_INFO("odd number of bytes to write (%" PRIu32 "), extending to %" PRIu32 " "
+			"and padding with 0xff", old_count, count);
+		memset(new_buffer, 0xff, count);
+		buffer = memcpy(new_buffer, buffer, old_count);
+	}
+
+	uint32_t words_remaining = count / 4;
+	int retval, retval2;
+
+	/* unlock flash registers */
+	efr32x_msc_lock(bank, 0);
+	retval = efr32x_set_wren(bank, 1);
+	if (retval != ERROR_OK)
+		goto cleanup;
+
+	/* try using a block write */
+	retval = efr32x_write_block(bank, buffer, offset, words_remaining);
+
+	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
+		/* if block write failed (no sufficient working area),
+		 * we use normal (slow) single word accesses */
+		LOG_WARNING("couldn't use block writes, falling back to single "
+			"memory accesses");
+
+		while (words_remaining > 0) {
+			uint32_t value;
+			memcpy(&value, buffer, sizeof(uint32_t));
+
+			retval = efr32x_write_word(bank, offset, value);
+			if (retval != ERROR_OK)
+				goto reset_pg_and_lock;
+
+			words_remaining--;
+			buffer += 4;
+			offset += 4;
+		}
+	}
+
+reset_pg_and_lock:
+	retval2 = efr32x_set_wren(bank, 0);
+	efr32x_msc_lock(bank, 1);
+	if (retval == ERROR_OK)
+		retval = retval2;
+
+cleanup:
+	if (new_buffer)
+		free(new_buffer);
+
+	return retval;
+}
+
+static int efr32x_probe(struct flash_bank *bank)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	struct efr32_info efr32_mcu_info;
+	int ret;
+	int i;
+	uint32_t base_address = 0x00000000;
+	char buf[256];
+
+	efr32x_info->probed = 0;
+	memset(efr32x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
+
+	ret = efr32x_read_info(bank, &efr32_mcu_info);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = efr32x_decode_info(&efr32_mcu_info, buf, sizeof(buf));
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_INFO("detected part: %s", buf);
+	LOG_INFO("flash size = %dkbytes", efr32_mcu_info.flash_sz_kib);
+	LOG_INFO("flash page size = %dbytes", efr32_mcu_info.page_size);
+
+	assert(0 != efr32_mcu_info.page_size);
+
+	int num_pages = efr32_mcu_info.flash_sz_kib * 1024 /
+		efr32_mcu_info.page_size;
+
+	assert(num_pages > 0);
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	bank->base = base_address;
+	bank->size = (num_pages * efr32_mcu_info.page_size);
+	bank->num_sectors = num_pages;
+
+	ret = efr32x_read_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read LB data");
+		return ret;
+	}
+
+	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	for (i = 0; i < num_pages; i++) {
+		bank->sectors[i].offset = i * efr32_mcu_info.page_size;
+		bank->sectors[i].size = efr32_mcu_info.page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	efr32x_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int efr32x_auto_probe(struct flash_bank *bank)
+{
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+	if (efr32x_info->probed)
+		return ERROR_OK;
+	return efr32x_probe(bank);
+}
+
+static int efr32x_protect_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	int ret = 0;
+	int i = 0;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	ret = efr32x_read_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read LB data");
+		return ret;
+	}
+
+	assert(NULL != bank->sectors);
+
+	for (i = 0; i < bank->num_sectors; i++)
+		bank->sectors[i].is_protected = efr32x_get_page_lock(bank, i);
+
+	return ERROR_OK;
+}
+
+static int get_efr32x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct efr32_info info;
+	int ret = 0;
+
+	ret = efr32x_read_info(bank, &info);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read EFR32 info");
+		return ret;
+	}
+
+	return efr32x_decode_info(&info, buf, buf_size);
+}
+
+COMMAND_HANDLER(efr32x_handle_debuglock_command)
+{
+	struct target *target = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct efr32x_flash_bank *efr32x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	uint32_t *ptr;
+	ptr = efr32x_info->lb_page + 127;
+	*ptr = 0;
+
+	retval = efr32x_write_lock_data(bank);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Failed to write LB page");
+		return retval;
+	}
+
+	command_print(CMD_CTX, "efr32x debug interface locked, reset the device to apply");
+
+	return ERROR_OK;
+}
+
+static const struct command_registration efr32x_exec_command_handlers[] = {
+	{
+		.name = "debuglock",
+		.handler = efr32x_handle_debuglock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lock the debug interface of the device.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration efr32x_command_handlers[] = {
+	{
+		.name = "efr32",
+		.mode = COMMAND_ANY,
+		.help = "efr32 flash command group",
+		.usage = "",
+		.chain = efr32x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver efr32_flash = {
+	.name = "efr32",
+	.commands = efr32x_command_handlers,
+	.flash_bank_command = efr32x_flash_bank_command,
+	.erase = efr32x_erase,
+	.protect = efr32x_protect,
+	.write = efr32x_write,
+	.read = default_flash_read,
+	.probe = efr32x_probe,
+	.auto_probe = efr32x_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = efr32x_protect_check,
+	.info = get_efr32x_info,
+};
diff --git a/src/flash/nor/mgm21.c b/src/flash/nor/mgm21.c
new file mode 100644
index 000000000..392ff56a6
--- /dev/null
+++ b/src/flash/nor/mgm21.c
@@ -0,0 +1,854 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath@gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 by Andreas Fritiofson                              *
+ *   andreas.fritiofson@gmail.com                                          *
+ *                                                                         *
+ *   Copyright (C) 2013 by Roman Dmitrienko                                *
+ *   me@iamroman.org                                                       *
+ *                                                                         *
+ *   Copyright (C) 2014 Nemui Trinomius                                    *
+ *   nemuisan_kawausogasuki@live.jp                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+#include <target/cortex_m.h>
+
+/* keep family IDs in decimal */
+#define EFR_FAMILY_ID_MIGHTY_GECKO      28
+#define EFR_FAMILY_ID_BLUE_GECKO        20
+#define EFR_FAMILY_ID_MIGHTY_GECKO_21	21
+
+#define MGM21_FLASH_ERASE_TMO           100
+#define MGM21_FLASH_WDATAREADY_TMO      100
+#define MGM21_FLASH_WRITE_TMO           100
+
+/* size in bytes, not words; must fit all Gecko devices */
+#define LOCKBITS_PAGE_SZ                512
+
+#define MGM21_MSC_INFO_BASE             0x0fe00000
+
+#define MGM21_MSC_USER_DATA             MGM21_MSC_INFO_BASE
+#define MGM21_MSC_LOCK_BITS             (MGM21_MSC_INFO_BASE+0x4000)
+#define MGM21_MSC_DEV_INFO              (MGM21_MSC_INFO_BASE+0x8000)
+
+/* PAGE_SIZE is only present in Leopard, Giant and Wonder Gecko MCUs */
+#define MGM21_MSC_DI_PAGE_SIZE          (MGM21_MSC_DEV_INFO+8)
+#define MGM21_MSC_DI_FLASH_SZ           (MGM21_MSC_DEV_INFO+12)
+#define MGM21_MSC_DI_RAM_SZ             (MGM21_MSC_DEV_INFO+14)
+#define MGM21_MSC_DI_PART_NUM           (MGM21_MSC_DEV_INFO+4)
+#define MGM21_MSC_DI_PART_FAMILY        (MGM21_MSC_DEV_INFO+6)
+#define MGM21_MSC_DI_PROD_REV           (MGM21_MSC_DEV_INFO+2)
+
+#define MGM21_MSC_REGBASE               0x40030000UL
+#define MGM21_MSC_WRITECTRL             (MGM21_MSC_REGBASE+12)
+#define MGM21_MSC_WRITECTRL_WREN_MASK   0x1
+#define MGM21_MSC_WRITECMD              (MGM21_MSC_REGBASE+16)
+#define MGM21_MSC_WRITECMD_LADDRIM_MASK 0x1
+#define MGM21_MSC_WRITECMD_ERASEPAGE_MASK 0x2
+#define MGM21_MSC_WRITECMD_WRITEONCE_MASK 0x8
+#define MGM21_MSC_ADDRB                 (MGM21_MSC_REGBASE+20)
+#define MGM21_MSC_WDATA                 (MGM21_MSC_REGBASE+24)
+#define MGM21_MSC_STATUS                (MGM21_MSC_REGBASE+28)
+#define MGM21_MSC_STATUS_BUSY_MASK      0x1
+#define MGM21_MSC_STATUS_LOCKED_MASK    0x2
+#define MGM21_MSC_STATUS_INVADDR_MASK   0x4
+#define MGM21_MSC_STATUS_WDATAREADY_MASK 0x8
+#define MGM21_MSC_STATUS_WORDTIMEOUT_MASK 0x10
+#define MGM21_MSC_STATUS_ERASEABORTED_MASK 0x20
+#define MGM21_MSC_LOCK                  (MGM21_MSC_REGBASE+60)
+#define MGM21_MSC_LOCK_LOCKKEY          0x1b71
+
+
+struct mgm21x_flash_bank {
+	int probed;
+	uint32_t lb_page[LOCKBITS_PAGE_SZ/4];
+};
+
+struct mgm21_info {
+	uint16_t flash_sz_kib;
+	uint16_t ram_sz_kib;
+	uint16_t part_num;
+	uint8_t part_family;
+	uint8_t prod_rev;
+	uint16_t page_size;
+};
+
+static int mgm21x_write(struct flash_bank *bank, const uint8_t *buffer,
+	uint32_t offset, uint32_t count);
+
+static int mgm21x_get_flash_size(struct flash_bank *bank, uint16_t *flash_sz)
+{
+	return target_read_u16(bank->target, MGM21_MSC_DI_FLASH_SZ, flash_sz);
+}
+
+static int mgm21x_get_ram_size(struct flash_bank *bank, uint16_t *ram_sz)
+{
+	return target_read_u16(bank->target, MGM21_MSC_DI_RAM_SZ, ram_sz);
+}
+
+static int mgm21x_get_part_num(struct flash_bank *bank, uint16_t *pnum)
+{
+	return target_read_u16(bank->target, MGM21_MSC_DI_PART_NUM, pnum);
+}
+
+static int mgm21x_get_part_family(struct flash_bank *bank, uint8_t *pfamily)
+{
+	return target_read_u8(bank->target, MGM21_MSC_DI_PART_FAMILY, pfamily);
+}
+
+static int mgm21x_get_prod_rev(struct flash_bank *bank, uint8_t *prev)
+{
+	return target_read_u8(bank->target, MGM21_MSC_DI_PROD_REV, prev);
+}
+
+static int mgm21x_read_info(struct flash_bank *bank,
+	struct mgm21_info *mgm21_info)
+{
+	int ret;
+	uint32_t cpuid = 0;
+
+	memset(mgm21_info, 0, sizeof(struct mgm21_info));
+
+	ret = target_read_u32(bank->target, CPUID, &cpuid);
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (((cpuid >> 4) & 0xfff) == 0xc23) {
+		/* Cortex-M3 device */
+	} else if (((cpuid >> 4) & 0xfff) == 0xc24) {
+		/* Cortex-M4 device (WONDER GECKO) */
+	} else if (((cpuid >> 4) & 0xfff) == 0xc60) {
+		/* Cortex-M0+ device */
+	} else if (((cpuid >> 4) & 0xfff) == 0xd21) {
+    	/* Cortex-M33 device */
+	} else {
+		LOG_ERROR("Target is not Cortex-Mx Device: %d", (cpuid >> 4) & 0xfff);
+		return ERROR_FAIL;
+	}
+
+	ret = mgm21x_get_flash_size(bank, &(mgm21_info->flash_sz_kib));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_get_ram_size(bank, &(mgm21_info->ram_sz_kib));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_get_part_num(bank, &(mgm21_info->part_num));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_get_part_family(bank, &(mgm21_info->part_family));
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_get_prod_rev(bank, &(mgm21_info->prod_rev));
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (EFR_FAMILY_ID_BLUE_GECKO == mgm21_info->part_family ||
+			EFR_FAMILY_ID_MIGHTY_GECKO == mgm21_info->part_family || 
+			EFR_FAMILY_ID_MIGHTY_GECKO_21 == mgm21_info->part_family) {
+		uint8_t pg_size = 0;
+		ret = target_read_u8(bank->target, MGM21_MSC_DI_FLASH_SZ,
+			&pg_size);
+		if (ERROR_OK != ret)
+			return ret;
+
+		mgm21_info->page_size = (1 << ((pg_size+10) & 0xff));
+		if (1024 != mgm21_info->page_size) {
+			LOG_ERROR("Invalid page size %u", mgm21_info->page_size);
+			return ERROR_FAIL;
+		}
+	} else {
+		LOG_ERROR("Unknown MCU family %d", mgm21_info->part_family);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Helper to create a human friendly string describing a part
+ */
+static int mgm21x_decode_info(struct mgm21_info *info, char *buf, int buf_size)
+{
+	int printed = 0;
+
+	switch (info->part_family) {
+		case EFR_FAMILY_ID_MIGHTY_GECKO_21:
+			printed = snprintf(buf, buf_size, "MGM21 ");
+			break;
+		default:
+			printed = snprintf(buf, buf_size, "Unknown ");
+	}
+
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+	printed = snprintf(buf, buf_size, " - Rev: %d", info->prod_rev);
+	buf += printed;
+	buf_size -= printed;
+
+	if (0 >= buf_size)
+		return ERROR_BUF_TOO_SMALL;
+
+	return ERROR_OK;
+}
+
+/* flash bank mgm21 <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(mgm21x_flash_bank_command)
+{
+	struct mgm21x_flash_bank *mgm21x_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	mgm21x_info = malloc(sizeof(struct mgm21x_flash_bank));
+
+	bank->driver_priv = mgm21x_info;
+	mgm21x_info->probed = 0;
+	memset(mgm21x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
+
+	return ERROR_OK;
+}
+
+/* set or reset given bits in a register */
+static int mgm21x_set_reg_bits(struct flash_bank *bank, uint32_t reg,
+	uint32_t bitmask, int set)
+{
+	int ret = 0;
+	uint32_t reg_val = 0;
+
+	ret = target_read_u32(bank->target, reg, &reg_val);
+	if (ERROR_OK != ret)
+		return ret;
+
+	if (set)
+		reg_val |= bitmask;
+	else
+		reg_val &= ~bitmask;
+
+	return target_write_u32(bank->target, reg, reg_val);
+}
+
+static int mgm21x_set_wren(struct flash_bank *bank, int write_enable)
+{
+	return mgm21x_set_reg_bits(bank, MGM21_MSC_WRITECTRL,
+		MGM21_MSC_WRITECTRL_WREN_MASK, write_enable);
+}
+
+static int mgm21x_msc_lock(struct flash_bank *bank, int lock)
+{
+	return target_write_u32(bank->target, MGM21_MSC_LOCK,
+		(lock ? 0 : MGM21_MSC_LOCK_LOCKKEY));
+}
+
+static int mgm21x_wait_status(struct flash_bank *bank, int timeout,
+	uint32_t wait_mask, int wait_for_set)
+{
+	int ret = 0;
+	uint32_t status = 0;
+
+	while (1) {
+		ret = target_read_u32(bank->target, MGM21_MSC_STATUS, &status);
+		if (ERROR_OK != ret)
+			break;
+
+		LOG_DEBUG("status: 0x%" PRIx32 "", status);
+
+		if (((status & wait_mask) == 0) && (0 == wait_for_set))
+			break;
+		else if (((status & wait_mask) != 0) && wait_for_set)
+			break;
+
+		if (timeout-- <= 0) {
+			LOG_ERROR("timed out waiting for MSC status");
+			return ERROR_FAIL;
+		}
+
+		alive_sleep(1);
+	}
+
+	if (status & MGM21_MSC_STATUS_ERASEABORTED_MASK)
+		LOG_WARNING("page erase was aborted");
+
+	return ret;
+}
+
+static int mgm21x_erase_page(struct flash_bank *bank, uint32_t addr)
+{
+	/* this function DOES NOT set WREN; must be set already */
+	/* 1. write address to ADDRB
+	   2. write LADDRIM
+	   3. check status (INVADDR, LOCKED)
+	   4. write ERASEPAGE
+	   5. wait until !STATUS_BUSY
+	 */
+	int ret = 0;
+	uint32_t status = 0;
+
+	LOG_DEBUG("erasing flash page at 0x%08" PRIx32, addr);
+
+	ret = target_write_u32(bank->target, MGM21_MSC_ADDRB, addr);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_set_reg_bits(bank, MGM21_MSC_WRITECMD,
+		MGM21_MSC_WRITECMD_LADDRIM_MASK, 1);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = target_read_u32(bank->target, MGM21_MSC_STATUS, &status);
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_DEBUG("status 0x%" PRIx32, status);
+
+	if (status & MGM21_MSC_STATUS_LOCKED_MASK) {
+		LOG_ERROR("Page is locked");
+		return ERROR_FAIL;
+	} else if (status & MGM21_MSC_STATUS_INVADDR_MASK) {
+		LOG_ERROR("Invalid address 0x%" PRIx32, addr);
+		return ERROR_FAIL;
+	}
+
+	ret = mgm21x_set_reg_bits(bank, MGM21_MSC_WRITECMD,
+		MGM21_MSC_WRITECMD_ERASEPAGE_MASK, 1);
+	if (ERROR_OK != ret)
+		return ret;
+
+	return mgm21x_wait_status(bank, MGM21_FLASH_ERASE_TMO,
+		MGM21_MSC_STATUS_BUSY_MASK, 0);
+}
+
+static int mgm21x_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int i = 0;
+	int ret = 0;
+
+	if (TARGET_HALTED != target->state) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	mgm21x_msc_lock(bank, 0);
+	ret = mgm21x_set_wren(bank, 1);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to enable MSC write");
+		return ret;
+	}
+
+	for (i = first; i <= last; i++) {
+		ret = mgm21x_erase_page(bank, bank->sectors[i].offset);
+		if (ERROR_OK != ret)
+			LOG_ERROR("Failed to erase page %d", i);
+	}
+
+	ret = mgm21x_set_wren(bank, 0);
+	mgm21x_msc_lock(bank, 1);
+
+	LOG_INFO("Device is successfull erased");
+
+	return ret;
+}
+
+static int mgm21x_read_lock_data(struct flash_bank *bank)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	struct target *target = bank->target;
+	int i = 0;
+	int data_size = 0;
+	uint32_t *ptr = NULL;
+	int ret = 0;
+
+	assert(bank->num_sectors > 0);
+
+	/* calculate the number of 32-bit words to read (one lock bit per sector) */
+	data_size = (bank->num_sectors + 31) / 32;
+
+	ptr = mgm21x_info->lb_page;
+
+	for (i = 0; i < data_size; i++, ptr++) {
+		ret = target_read_u32(target, MGM21_MSC_LOCK_BITS+i*4, ptr);
+		if (ERROR_OK != ret) {
+			LOG_ERROR("Failed to read PLW %d", i);
+			return ret;
+		}
+	}
+
+	/* also, read ULW, DLW and MLW */
+
+	/* ULW, word 126 */
+	ptr = mgm21x_info->lb_page + 126;
+	ret = target_read_u32(target, MGM21_MSC_LOCK_BITS+126*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read ULW");
+		return ret;
+	}
+
+	/* DLW, word 127 */
+	ptr = mgm21x_info->lb_page + 127;
+	ret = target_read_u32(target, MGM21_MSC_LOCK_BITS+127*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read DLW");
+		return ret;
+	}
+
+	/* MLW, word 125, present in GG and LG */
+	ptr = mgm21x_info->lb_page + 125;
+	ret = target_read_u32(target, MGM21_MSC_LOCK_BITS+125*4, ptr);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read MLW");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int mgm21x_write_lock_data(struct flash_bank *bank)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	int ret = 0;
+
+	ret = mgm21x_erase_page(bank, MGM21_MSC_LOCK_BITS);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to erase LB page");
+		return ret;
+	}
+
+	return mgm21x_write(bank, (uint8_t *)mgm21x_info->lb_page, MGM21_MSC_LOCK_BITS,
+		LOCKBITS_PAGE_SZ);
+}
+
+static int mgm21x_get_page_lock(struct flash_bank *bank, size_t page)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	uint32_t dw = mgm21x_info->lb_page[page >> 5];
+	uint32_t mask = 0;
+
+	mask = 1 << (page & 0x1f);
+
+	return (dw & mask) ? 0 : 1;
+}
+
+static int mgm21x_set_page_lock(struct flash_bank *bank, size_t page, int set)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	uint32_t *dw = &mgm21x_info->lb_page[page >> 5];
+	uint32_t mask = 0;
+
+	mask = 1 << (page & 0x1f);
+
+	if (!set)
+		*dw |= mask;
+	else
+		*dw &= ~mask;
+
+	return ERROR_OK;
+}
+
+static int mgm21x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct target *target = bank->target;
+	int i = 0;
+	int ret = 0;
+
+	if (!set) {
+		LOG_ERROR("Erase device data to reset page locks");
+		return ERROR_FAIL;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	for (i = first; i <= last; i++) {
+		ret = mgm21x_set_page_lock(bank, i, set);
+		if (ERROR_OK != ret) {
+			LOG_ERROR("Failed to set lock on page %d", i);
+			return ret;
+		}
+	}
+
+	ret = mgm21x_write_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to write LB page");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int mgm21x_write_block(struct flash_bank *bank, const uint8_t *buf,
+	uint32_t offset, uint32_t count)
+{
+	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+}
+
+static int mgm21x_write_word(struct flash_bank *bank, uint32_t addr,
+	uint32_t val)
+{
+	/* this function DOES NOT set WREN; must be set already */
+	/* 1. write address to ADDRB
+	   2. write LADDRIM
+	   3. check status (INVADDR, LOCKED)
+	   4. wait for WDATAREADY
+	   5. write data to WDATA
+	   6. write WRITECMD_WRITEONCE to WRITECMD
+	   7. wait until !STATUS_BUSY
+	 */
+
+	/* FIXME: MGM21G ref states (7.3.2) that writes should be
+	 * performed twice per dword */
+
+	int ret = 0;
+	uint32_t status = 0;
+
+	/* if not called, GDB errors will be reported during large writes */
+	keep_alive();
+
+	ret = target_write_u32(bank->target, MGM21_MSC_ADDRB, addr);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = target_read_u32(bank->target, MGM21_MSC_STATUS, &status);
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_DEBUG("status 0x%" PRIx32, status);
+
+	if (status & MGM21_MSC_STATUS_LOCKED_MASK) {
+		LOG_ERROR("Page is locked");
+		return ERROR_FAIL;
+	} else if (status & MGM21_MSC_STATUS_INVADDR_MASK) {
+		LOG_ERROR("Invalid address 0x%" PRIx32, addr);
+		return ERROR_FAIL;
+	}
+
+	ret = mgm21x_wait_status(bank, MGM21_FLASH_WDATAREADY_TMO,
+		MGM21_MSC_STATUS_WDATAREADY_MASK, 1);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Wait for WDATAREADY failed");
+		return ret;
+	}
+
+	ret = target_write_u32(bank->target, MGM21_MSC_WDATA, val);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("WDATA write failed");
+		return ret;
+	}
+
+	ret = target_write_u32(bank->target, MGM21_MSC_WRITECMD,
+		MGM21_MSC_WRITECMD_WRITEONCE_MASK);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("WRITECMD write failed");
+		return ret;
+	}
+
+	ret = mgm21x_wait_status(bank, MGM21_FLASH_WRITE_TMO,
+		MGM21_MSC_STATUS_BUSY_MASK, 0);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Wait for BUSY failed");
+		return ret;
+	}
+
+	return ERROR_OK;
+}
+
+static int mgm21x_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint8_t *new_buffer = NULL;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x3) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte "
+			"alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	if (count & 0x3) {
+		uint32_t old_count = count;
+		count = (old_count | 3) + 1;
+		new_buffer = malloc(count);
+		if (new_buffer == NULL) {
+			LOG_ERROR("odd number of bytes to write and no memory "
+				"for padding buffer");
+			return ERROR_FAIL;
+		}
+		LOG_INFO("odd number of bytes to write (%" PRIu32 "), extending to %" PRIu32 " "
+			"and padding with 0xff", old_count, count);
+		memset(new_buffer, 0xff, count);
+		buffer = memcpy(new_buffer, buffer, old_count);
+	}
+
+	uint32_t words_remaining = count / 4;
+	int retval, retval2;
+
+	/* unlock flash registers */
+	mgm21x_msc_lock(bank, 0);
+	retval = mgm21x_set_wren(bank, 1);
+	if (retval != ERROR_OK)
+		goto cleanup;
+
+	/* try using a block write */
+	retval = mgm21x_write_block(bank, buffer, offset, words_remaining);
+
+	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
+		/* if block write failed (no sufficient working area),
+		 * we use normal (slow) single word accesses */
+		LOG_WARNING("couldn't use block writes, falling back to single "
+			"memory accesses");
+
+		while (words_remaining > 0) {
+			uint32_t value;
+			memcpy(&value, buffer, sizeof(uint32_t));
+
+			retval = mgm21x_write_word(bank, offset, value);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Word write failed at address: %d", offset);
+				goto reset_pg_and_lock;
+			}
+
+			words_remaining--;
+			buffer += 4;
+			offset += 4;
+		}
+	}
+
+reset_pg_and_lock:
+	retval2 = mgm21x_set_wren(bank, 0);
+	mgm21x_msc_lock(bank, 1);
+	if (retval == ERROR_OK)
+		retval = retval2;
+
+cleanup:
+	if (new_buffer)
+		free(new_buffer);
+
+	return retval;
+}
+
+static int mgm21x_probe(struct flash_bank *bank)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	struct mgm21_info mgm21_mcu_info;
+	int ret;
+	int i;
+	uint32_t base_address = 0x00000000;
+	char buf[256];
+
+	mgm21x_info->probed = 0;
+	memset(mgm21x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
+
+	ret = mgm21x_read_info(bank, &mgm21_mcu_info);
+	if (ERROR_OK != ret)
+		return ret;
+
+	ret = mgm21x_decode_info(&mgm21_mcu_info, buf, sizeof(buf));
+	if (ERROR_OK != ret)
+		return ret;
+
+	LOG_INFO("detected part: %s", buf);
+	LOG_INFO("flash size = %dkbytes", mgm21_mcu_info.flash_sz_kib);
+	LOG_INFO("flash page size = %dbytes", mgm21_mcu_info.page_size);
+
+	assert(0 != mgm21_mcu_info.page_size);
+
+	int num_pages = mgm21_mcu_info.flash_sz_kib * 1024 /
+		mgm21_mcu_info.page_size;
+
+	assert(num_pages > 0);
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	bank->base = base_address;
+	bank->size = (num_pages * mgm21_mcu_info.page_size);
+	bank->num_sectors = num_pages;
+
+	ret = mgm21x_read_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read LB data");
+		return ret;
+	}
+
+	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	for (i = 0; i < num_pages; i++) {
+		bank->sectors[i].offset = i * mgm21_mcu_info.page_size;
+		bank->sectors[i].size = mgm21_mcu_info.page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	mgm21x_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int mgm21x_auto_probe(struct flash_bank *bank)
+{
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+	if (mgm21x_info->probed)
+		return ERROR_OK;
+	return mgm21x_probe(bank);
+}
+
+static int mgm21x_protect_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	int ret = 0;
+	int i = 0;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	ret = mgm21x_read_lock_data(bank);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read LB data");
+		return ret;
+	}
+
+	assert(NULL != bank->sectors);
+
+	for (i = 0; i < bank->num_sectors; i++)
+		bank->sectors[i].is_protected = mgm21x_get_page_lock(bank, i);
+
+	return ERROR_OK;
+}
+
+static int get_mgm21x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct mgm21_info info;
+	int ret = 0;
+
+	ret = mgm21x_read_info(bank, &info);
+	if (ERROR_OK != ret) {
+		LOG_ERROR("Failed to read MGM21 info");
+		return ret;
+	}
+
+	return mgm21x_decode_info(&info, buf, buf_size);
+}
+
+COMMAND_HANDLER(mgm21x_handle_debuglock_command)
+{
+	struct target *target = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct mgm21x_flash_bank *mgm21x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	uint32_t *ptr;
+	ptr = mgm21x_info->lb_page + 127;
+	*ptr = 0;
+
+	retval = mgm21x_write_lock_data(bank);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Failed to write LB page");
+		return retval;
+	}
+
+	command_print(CMD_CTX, "mgm21x debug interface locked, reset the device to apply");
+
+	return ERROR_OK;
+}
+
+static const struct command_registration mgm21x_exec_command_handlers[] = {
+	{
+		.name = "debuglock",
+		.handler = mgm21x_handle_debuglock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lock the debug interface of the device.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration mgm21x_command_handlers[] = {
+	{
+		.name = "mgm21",
+		.mode = COMMAND_ANY,
+		.help = "mgm21 flash command group",
+		.usage = "",
+		.chain = mgm21x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver mgm21_flash = {
+	.name = "mgm21",
+	.commands = mgm21x_command_handlers,
+	.flash_bank_command = mgm21x_flash_bank_command,
+	.erase = mgm21x_erase,
+	.protect = mgm21x_protect,
+	.write = mgm21x_write,
+	.read = default_flash_read,
+	.probe = mgm21x_probe,
+	.auto_probe = mgm21x_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = mgm21x_protect_check,
+	.info = get_mgm21x_info,
+};
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 2aaf8fd84..4a873240f 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -143,6 +143,9 @@ endif
 if CMSIS_DAP
 DRIVERFILES += cmsis_dap_usb.c
 endif
+if BBG_SWD
+DRIVERFILES += bbg-swd.c
+endif
 
 noinst_HEADERS = \
 	bitbang.h \
diff --git a/src/jtag/drivers/bbg-swd.c b/src/jtag/drivers/bbg-swd.c
new file mode 100644
index 000000000..4d9a6366c
--- /dev/null
+++ b/src/jtag/drivers/bbg-swd.c
@@ -0,0 +1,408 @@
+/***************************************************************************
+ *   Copyright (C) 2016  Flying Stone Technology                           *
+ *   Author: NIIBE Yutaka <gniibe@fsij.org>                                *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include <jtag/swd.h>
+
+#include <prussdrv.h>
+#include <pruss_intc_mapping.h>
+
+#define PRU_NUM 	 0
+
+extern struct jtag_interface *jtag_interface;
+static void bbg_swd_write_reg(uint8_t cmd, uint32_t value, uint32_t ap_delay_clk);
+static int bbg_swd_switch_seq(enum swd_special_seq seq);
+
+static void pru_request_cmd(uint32_t *p)
+{
+	/* Wakeup the PRU0 which sleeps.  */
+	prussdrv_pru_send_event(ARM_PRU0_INTERRUPT);
+
+	/* Wait PRU0 response.  */
+	prussdrv_pru_wait_event(PRU_EVTOUT_0);
+	prussdrv_pru_clear_event(PRU_EVTOUT_0, PRU0_ARM_INTERRUPT);
+	if ((p[0] & 0xff) == 4 || (p[0] & 0xff) == 5 || (p[0] & 0xff) == 7)
+		LOG_DEBUG("BBD-SWD: command execution (%08x:%08x)", p[0], p[1]);
+	else
+		LOG_DEBUG("BBD-SWD: command execution (%08x)", p[0]);
+}
+
+static int queued_retval;
+
+#define PRU_SWD_PROGRAM_PATH PKGDATADIR "/bbg-swd/pru-swd.bin"
+
+static uint32_t *pru_data_ram;
+static tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA;
+
+static int bbg_swd_open(void)
+{
+	int r;
+
+	LOG_DEBUG("bbg_swd_init");
+
+	/* Initialize the PRUSS driver.  */
+	prussdrv_init();
+
+	/* Open PRU interrupt to Host.  */
+	r = prussdrv_open(PRU_EVTOUT_0);
+	if (r < 0) {
+		LOG_ERROR("prussdrv_open open failed: %d", r);
+		return ERROR_FAIL;
+	}
+
+	/* Initialize PRU interrupt controller.  */
+	prussdrv_pruintc_init(&pruss_intc_initdata);
+
+	/* Initialize PRU memory access from Host.  */
+	r = prussdrv_map_prumem(PRUSS0_PRU0_DATARAM, (void **)&pru_data_ram);
+	if (r < 0) {
+		prussdrv_exit();
+		LOG_ERROR("prussdrv_map_prumem failed: %d", r);
+		return ERROR_FAIL;
+	}
+
+	/* Execute example on PRU */
+	LOG_DEBUG("Executing PRU-SWU program on PRUSS");
+	r = prussdrv_exec_program(PRU_NUM, PRU_SWD_PROGRAM_PATH);
+	if (r < 0) {
+		prussdrv_exit();
+		LOG_ERROR("prussdrv_exec_program failed: %d", r);
+		return ERROR_FAIL;
+	}
+	return ERROR_OK;
+}
+
+
+static int bbg_swd_close(void)
+{
+	/* Disable PRU.  */
+	prussdrv_pru_disable(PRU_NUM);
+	prussdrv_exit();
+	return ERROR_OK;
+}
+
+
+static void bbg_swd_gpio_srst(int on);
+
+static bool swd_mode;
+
+static int bbg_swd_interface_init(void)
+{
+	int retval;
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	if (swd_mode) {
+		retval = bbg_swd_open();
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	if (jtag_reset_config & RESET_CNCT_UNDER_SRST) {
+		if (jtag_reset_config & RESET_SRST_NO_GATING) {
+			bbg_swd_gpio_srst(0);
+			LOG_INFO("Connecting under reset");
+		}
+	}
+
+	LOG_INFO("BBG-SWD: Interface ready");
+
+	return ERROR_OK;
+}
+
+static int bbg_swd_interface_quit(void)
+{
+	bbg_swd_close();
+	return ERROR_OK;
+}
+
+static int bbg_swd_swd_init(void)
+{
+	swd_mode = true;
+	return ERROR_OK;
+}
+
+enum {
+	CMD_HALT = 0,
+	CMD_BLINK,
+	CMD_GPIO_OUT,
+	CMD_GPIO_IN,
+	CMD_SIG_IDLE,
+	CMD_SIG_GEN,
+	CMD_READ_REG,
+	CMD_WRITE_REG
+};
+
+#define BBG_SWS_RESULT 16
+
+/* 
+ * Signal patterns are defined in:
+ *	ARM Debug Interface Architecture Specification (ADI)
+ */
+static const uint8_t seq_jtag_to_swd[] = { 0xde, 0xf9 };
+static const int seq_jtag_to_swd_len = 16;
+static const uint8_t seq_swd_to_seq[] = { 0x3c, 0xe7 };
+static const int seq_swd_to_jtag_len = 16;
+
+static void bbg_swd_idle(int count)
+{
+	pru_data_ram[0] = CMD_SIG_IDLE;
+	pru_data_ram[1] = count;
+	pru_request_cmd(pru_data_ram);
+}
+
+static void bbg_swd_gpio_srst(int signal)
+{
+	pru_data_ram[0] = CMD_GPIO_OUT;
+	pru_data_ram[1] = (1 << 15);
+	pru_data_ram[2] = signal ? 1 : 0;
+	pru_request_cmd(pru_data_ram);
+}
+
+static int bbg_swd_switch_seq(enum swd_special_seq seq)
+{
+	LOG_DEBUG("bbg_swd_switch_seq");
+
+	switch (seq) {
+	case LINE_RESET:
+		LOG_DEBUG("SWD line reset");
+		pru_data_ram[0] = CMD_SIG_GEN | (swd_seq_line_reset_len << 8);
+		memcpy (&pru_data_ram[1], swd_seq_line_reset, (swd_seq_line_reset_len+7)/8);
+		pru_request_cmd(pru_data_ram);
+		break;
+	case JTAG_TO_SWD:
+		LOG_DEBUG("JTAG-to-SWD");
+		pru_data_ram[0] = CMD_SIG_GEN | ((swd_seq_jtag_to_swd_len)<< 8);
+		memcpy (&pru_data_ram[1], swd_seq_jtag_to_swd, (swd_seq_jtag_to_swd_len+7)/8);
+		pru_request_cmd(pru_data_ram);
+		bbg_swd_idle(8);
+		break;
+	case SWD_TO_JTAG:
+		LOG_DEBUG("SWD-to-JTAG");
+		pru_data_ram[0] = CMD_SIG_GEN | (swd_seq_swd_to_jtag_len << 8);
+		memcpy (&pru_data_ram[1], swd_seq_swd_to_jtag, (swd_seq_swd_to_jtag_len+7)/8);
+		pru_request_cmd(pru_data_ram);
+		break;
+	default:
+		LOG_ERROR("Sequence %d not supported", seq);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+
+static void bbg_swd_read_reg(uint8_t cmd, uint32_t *value, uint32_t ap_delay_clk)
+{
+	int ack;
+	int parity;
+	uint32_t data;
+	uint32_t delay = 0;
+
+	LOG_DEBUG("bbg_swd_read_reg");
+	assert(cmd & SWD_CMD_RnW);
+	assert(ap_delay_clk < 256);
+
+	if (queued_retval != ERROR_OK) {
+		LOG_DEBUG("Skip bbg_swd_read_reg because queued_retval=%d", queued_retval);
+		return;
+	}
+
+	if (cmd & SWD_CMD_APnDP)
+		delay = ap_delay_clk;
+
+	cmd |= 0x81;
+	pru_data_ram[0] = CMD_READ_REG | (cmd << 8) | (delay << 24);
+	pru_request_cmd(pru_data_ram);
+	ack = pru_data_ram[BBG_SWS_RESULT] & 0x07;
+	parity = (pru_data_ram[BBG_SWS_RESULT] & 0x80000000) != 0;
+	data = pru_data_ram[BBG_SWS_RESULT+1];
+
+	LOG_DEBUG("%s %s %s reg %X = %08" PRIx32,
+		  ack == SWD_ACK_OK ? "OK" : ack == SWD_ACK_WAIT ? "WAIT" : ack == SWD_ACK_FAULT ? "FAULT" : "JUNK",
+		  cmd & SWD_CMD_APnDP ? "AP" : "DP",
+		  cmd & SWD_CMD_RnW ? "read" : "write",
+		  (cmd & SWD_CMD_A32) >> 1,
+		  data);
+
+	if (ack != SWD_ACK_OK) {
+		queued_retval = ack == SWD_ACK_WAIT ? ERROR_WAIT : ERROR_FAIL;
+	} else if (parity != parity_u32(data)) {
+		LOG_DEBUG("Wrong parity detected (%d)", parity);
+		queued_retval = ERROR_FAIL;
+	} else if (value) {
+		*value = data;
+		queued_retval = ERROR_OK;
+	}
+}
+
+static void bbg_swd_write_reg(uint8_t cmd, uint32_t value, uint32_t ap_delay_clk)
+{
+	int ack;
+	int parity = parity_u32(value);
+	uint32_t delay = 0;
+
+	LOG_DEBUG("bbg_swd_write_reg");
+	assert(!(cmd & SWD_CMD_RnW));
+	assert(ap_delay_clk < 256);
+
+	if (queued_retval != ERROR_OK) {
+		LOG_DEBUG("Skip bbg_swd_write_reg because queued_retval=%d", queued_retval);
+		return;
+	}
+
+	if (cmd & SWD_CMD_APnDP)
+		delay = ap_delay_clk;
+
+	cmd |= 0x81;
+	pru_data_ram[0] = CMD_WRITE_REG | (cmd << 8) | (parity << 16) | (delay << 24);
+	pru_data_ram[1] = value;
+	pru_request_cmd(pru_data_ram);
+	ack = pru_data_ram[BBG_SWS_RESULT] & 0x07;
+
+	LOG_DEBUG("%s %s %s reg %X = %08" PRIx32,
+		  ack == SWD_ACK_OK ? "OK" : ack == SWD_ACK_WAIT ? "WAIT" : ack == SWD_ACK_FAULT ? "FAULT" : "JUNK",
+		  cmd & SWD_CMD_APnDP ? "AP" : "DP",
+		  cmd & SWD_CMD_RnW ? "read" : "write",
+		  (cmd & SWD_CMD_A32) >> 1,
+		  value);
+
+	if (ack != SWD_ACK_OK)
+		queued_retval = ack == SWD_ACK_WAIT ? ERROR_WAIT : ERROR_FAIL;
+}
+
+static int bbg_swd_run_queue(void)
+{
+	int retval;
+
+	LOG_DEBUG("bbg_swd_run_queue");
+	bbg_swd_idle(8);
+	retval = queued_retval;
+	queued_retval = ERROR_OK;
+	LOG_DEBUG("SWD queue return value: %02x", retval);
+	return retval;
+}
+
+const struct swd_driver bbg_swd = {
+	.init = bbg_swd_swd_init,
+	.switch_seq = bbg_swd_switch_seq,
+	.read_reg = bbg_swd_read_reg,
+	.write_reg = bbg_swd_write_reg,
+	.run = bbg_swd_run_queue,
+};
+
+
+static const char * const bbg_swd_transport[] = { "swd", NULL };
+
+
+COMMAND_HANDLER(bbg_swd_handle_hello_command)
+{
+	puts("Hello!");
+	return ERROR_OK;
+}
+
+static const struct command_registration bbg_swd_command_handlers[] = {
+	{
+		.name = "bbg_swd_hello",
+		.handler = &bbg_swd_handle_hello_command,
+		.mode = COMMAND_CONFIG,
+		.help = "hello command for BBG-SWD",
+		.usage = "<cmd>",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static void bbg_swd_execute_reset(struct jtag_command *cmd)
+{
+	bbg_swd_gpio_srst(cmd->cmd.reset->srst ? 0: 1);
+}
+
+static void bbg_swd_execute_sleep(struct jtag_command *cmd)
+{
+	jtag_sleep(cmd->cmd.sleep->us);
+}
+
+static void bbg_swd_execute_command(struct jtag_command *cmd)
+{
+	switch (cmd->type) {
+		case JTAG_RESET:
+			bbg_swd_execute_reset(cmd);
+			break;
+		case JTAG_SLEEP:
+			bbg_swd_execute_sleep(cmd);
+			break;
+		default:
+			LOG_ERROR("BUG: unknown JTAG command type encountered");
+			exit(-1);
+	}
+}
+
+static int bbg_swd_interface_execute_queue(void)
+{
+	struct jtag_command *cmd = jtag_command_queue;
+
+	while (cmd != NULL) {
+		bbg_swd_execute_command(cmd);
+		cmd = cmd->next;
+	}
+
+	return ERROR_OK;
+}
+
+static int bbg_swd_interface_speed(int speed)
+{
+	return ERROR_OK;
+}
+
+static int bbg_swd_interface_speed_div(int speed, int *khz)
+{
+	*khz = speed;
+	return ERROR_OK;
+}
+
+static int bbg_swd_interface_khz(int khz, int *jtag_speed)
+{
+	*jtag_speed = khz;
+	return ERROR_OK;
+}
+
+struct jtag_interface bbg_swd_interface = {
+	.name = "bbg-swd",
+	.commands = bbg_swd_command_handlers,
+	.swd = &bbg_swd,
+	.transports = bbg_swd_transport,
+
+	.execute_queue = bbg_swd_interface_execute_queue,
+	.speed = bbg_swd_interface_speed,
+	.speed_div = bbg_swd_interface_speed_div,
+	.khz = bbg_swd_interface_khz,
+
+	.init = bbg_swd_interface_init,
+	.quit = bbg_swd_interface_quit,
+};
+/*
+ * Local Variables:
+ * c-file-style: "linux"
+ * End:
+ */
diff --git a/src/jtag/drivers/bbg-swd.h b/src/jtag/drivers/bbg-swd.h
new file mode 100644
index 000000000..f0c92b3f6
--- /dev/null
+++ b/src/jtag/drivers/bbg-swd.h
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *   Copyright (C) 2016  Flying Stone Technology                           *
+ *   Author: NIIBE Yutaka <gniibe@fsij.org>                                *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef BBG_SWD_H
+#define BBG_SWD_H
+
+#include <jtag/swd.h>
+
+struct bbg_swd_interface {
+	/* low level callbacks (for bbg_swd)
+	 */
+	int (*read)(void);
+	void (*write)(int tck, int tms, int tdi);
+	void (*reset)(int trst, int srst);
+	void (*blink)(int on);
+	int (*swdio_read)(void);
+	void (*swdio_drive)(bool on);
+};
+
+const struct swd_driver bbg_swd_swd;
+
+int bbg_swd_execute_queue(void);
+
+extern struct jtag_interface bbg_swd_interface;
+int bbg_swd_swd_switch_seq(enum swd_special_seq seq);
+
+#endif /* BBG_SWD_H */
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index 64fdd71d6..5266372e6 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -129,6 +129,9 @@ extern struct jtag_interface bcm2835gpio_interface;
 #if BUILD_CMSIS_DAP == 1
 extern struct jtag_interface cmsis_dap_interface;
 #endif
+#if BUILD_BBG_SWD == 1
+extern struct jtag_interface bbg_swd_interface;
+#endif
 #endif /* standard drivers */
 
 /**
@@ -228,6 +231,9 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_CMSIS_DAP == 1
 		&cmsis_dap_interface,
 #endif
+#if BUILD_BBG_SWD == 1
+		&bbg_swd_interface,
+#endif
 #endif /* standard drivers */
 		NULL,
 	};
diff --git a/tcl/board/efr32.cfg b/tcl/board/efr32.cfg
new file mode 100644
index 000000000..aa95ce1eb
--- /dev/null
+++ b/tcl/board/efr32.cfg
@@ -0,0 +1,11 @@
+# Configuration for EFM32 boards with on-board SEGGER J-Link
+#
+# Tested with Tiny, Giant and Zero Gecko Starter Kit.
+#
+
+source [find interface/jlink.cfg]
+transport select swd
+adapter_khz 1000
+
+set CHIPNAME efr32
+source [find target/efr32.cfg]
diff --git a/tcl/board/mgm21.cfg b/tcl/board/mgm21.cfg
new file mode 100644
index 000000000..8700feb2a
--- /dev/null
+++ b/tcl/board/mgm21.cfg
@@ -0,0 +1,11 @@
+# Configuration for EFM32 boards with on-board SEGGER J-Link
+#
+# Tested with Tiny, Giant and Zero Gecko Starter Kit.
+#
+
+source [find interface/jlink.cfg]
+transport select swd
+adapter_khz 1000
+
+set CHIPNAME mgm21
+source [find target/mgm21.cfg]
diff --git a/tcl/target/efr32.cfg b/tcl/target/efr32.cfg
new file mode 100644
index 000000000..74d91b13c
--- /dev/null
+++ b/tcl/target/efr32.cfg
@@ -0,0 +1,43 @@
+#
+# efm32 target
+#
+
+source [find target/swj-dp.tcl]
+
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME efr32
+}
+
+# Work-area is a space in RAM used for flash programming
+# By default use 2kB
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x800
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x2ba01477
+}
+
+swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
+
+adapter_khz 1000
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -chain-position $_TARGETNAME
+
+$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME efr32 0 0 0 0 $_TARGETNAME
+
+if {![using_hla]} {
+   # if srst is not fitted use SYSRESETREQ to
+   # perform a soft reset
+   cortex_m reset_config sysresetreq
+}
diff --git a/tcl/target/mgm21.cfg b/tcl/target/mgm21.cfg
new file mode 100644
index 000000000..f2cd02d26
--- /dev/null
+++ b/tcl/target/mgm21.cfg
@@ -0,0 +1,43 @@
+#
+# mgm21 target
+#
+
+source [find target/swj-dp.tcl]
+
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME mgm21
+}
+
+# Work-area is a space in RAM used for flash programming
+# By default use 2kB
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x800
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x2ba01477
+}
+
+swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
+
+adapter_khz 1000
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -chain-position $_TARGETNAME
+
+$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME mgm21 0 0 0 0 $_TARGETNAME
+
+if {![using_hla]} {
+   # if srst is not fitted use SYSRESETREQ to
+   # perform a soft reset
+   cortex_m reset_config sysresetreq
+}
