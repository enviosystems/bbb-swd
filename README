BeagleBoneGreen SWD - a practical tool for computing freedom

					    		Version 0.04
							  2018-08-22
							Niibe Yutaka
					     Flying Stone Technology

BeagleBoneGreen SWD
===================

BeagleBoneGreen SWD (BBG-SWD) is a tool to control SWD protocol by
BeagleBoneGreen or PocketBeagle.


Note for release 0.04
=====================

The patches are against OpenOCD 0.10.0.

	0001-jtag-drivers-bbg-swd-New-SWD-driver.patch
	0002-jtag-bbg-swd-Fix-bbg_swd_interface_init-and-bbg_swd_.patch
	0003-target-cortex_m-Set-do_reconnect-at-deassert.patch
	0004-target-cortex-m-More-wait-tick.patch

The BBG-SWD driver is ready for use.  It is tested with FST-01G
(STM32F103), FSM-55 (STM32F030) and prototype of FS-BB48 (KL27Z256).

Use of "bone-kernel" is assumed for UIO user space PRUSS driver.

It is also tested with PocketBeagle.

The delay constant in pru-swd.p is changed for speed.  And I modified
original OpenOCD Cortex-M target, so that it works for my boards.


Future Works
============

It would be good to support different speed for communication.


The purpose
===========

It gives (back) us the control for our computing (freedom), again.


Pins for SWD access
===================

For BBG
-------

SWD-DIO		P8_11
SWD-CLK		P8_12
SRST		P8_15

Pinmux Configuration

    # echo gpio >/sys/devices/platform/ocp/ocp:P8_11_pinmux/state
    # echo gpio >/sys/devices/platform/ocp/ocp:P8_12_pinmux/state
    # echo gpio_pu >/sys/devices/platform/ocp/ocp:P8_15_pinmux/state


For PocketBeagle
----------------

SWD-DIO		P2_33
SWD-CLK		P2_24
SRST		P2_18
3V3		P2_23
GND		P2_21

Pinmux Configuration

    # echo gpio >/sys/devices/platform/ocp/ocp:P2_24_pinmux/state
    # echo gpio >/sys/devices/platform/ocp/ocp:P2_33_pinmux/state
    # echo gpio_pu >/sys/devices/platform/ocp/ocp:P2_18_pinmux/state



The methodology
===============

It takes advantage of using PRUSS (Programmable Realtime Unit
SubSytem) on the processor, so that the SWD communication could be
reliable, accurate and fast.

It assumes use of PRUSSDRV user space library with UIO user space
PRUSS driver.

I use "bone-kernel" for that.


Software License
================

The program pru-swd.p is distributed under GPLv3+.

The OpenOCD patch  is under GPLv2+.


Patches for OpenOCD
===================

The patch is: 0001-Add-new-SWD-driver-bbg-swd.patch

This was for OpenOCD, and it was against the commit: ::

        406f4d1c68330e3bf8d9db4e402fd8802a5c79e2

The root file system I use was based on Debian Jessie.  /ID.txt said: ::

        BeagleBoard.org Debian Image 2016-01-24

The kernel in use was 4.4.145-bone-rt-r23.

For BBG-SWD, "ti-rt" kernel does not work well because PRUSS support
is different in this kernel.

To build pru-swd.p run

		pasm -b -V3 pru-swd.p

I put the program for PRUSS in: ::

        /usr/local/share/openocd/bbg-swd/pru-swd.bin

-- 

Apply patch
-----
To apply the patch, you need to first, validate the patch

	cd <openocd_source_directory>
	git apply --stat <path_to_patch>/<patch>

A dry run is recommended before applying patch to the project

	git apply --check <path_to_patch>/<patch>

If no error is shown above, then you can safely apply the patch

	patch -p1 < <path_to_patch>/<patch>



Then, you can configure BBG-SWD driver by the --enable-bbg-swd option.

    ./configure --enable-bbg-swd

You can use it with a configuration like:

-------------------------- File: bbg-swd.cfg
interface bbg-swd
transport select swd
--------------------------

The invacatio of command is something like this:

    $ openocd -f  bbg-swd.cfg -f target/stm32f1x.cfg

The above is the case for FST-01.


For FS-BB48 (which uses Freescale's KL27Z256), I use following configuration.

MGM21 flashing examples
==============================

There are several binaries available for MGM21 flashing in Binaries folder. To flash `ncp-uart-sw.hex` file simply run

    $ openocd -f  flash-ncp-uart-sw.cfg

This is a binary for Zigbee NCP UART. To test it on UART1 run

    $ siliconlabsgateway -n 0 -p /dev/ttyS1

Tho output should be something like this:
```
Reset info: 11 (SOFTWARE)
ezsp ver 0x08 stack type 0x02 stack ver. [6.7.7 GA build 347]
Ezsp Config: set security level to 0x0005:Success: set
Ezsp Config: set address table size to 0x0002:Success: set
Ezsp Config: set TC addr cache to 0x0002:Success: set
Ezsp Config: set stack profile to 0x0002:Success: set
Ezsp Config: set MAC indirect TX timeout to 0x1E00:Success: set
Ezsp Config: set max hops to 0x001E:Success: set
Ezsp Config: set tx power mode to 0x8000:Success: set
Ezsp Config: set supported networks to 0x0001:Success: set
Ezsp Value : set end device keep alive support mode to 0x00000003:Success: set
Ezsp Policy: set binding modify to "allow for valid endpoints & clusters only":Success: set
Ezsp Policy: set message content in msgSent to "return":Success: set
Ezsp Value : set maximum incoming transfer size to 0x00000052:Success: set
Ezsp Value : set maximum outgoing transfer size to 0x00000052:Success: set
Ezsp Config: set binding table size to 0x0010:Success: set
Ezsp Config: set key table size to 0x0004:Success: set
Ezsp Config: set max end device children to 0x0020:Success: set
Ezsp Config: set aps unicast message count to 0x000A:Success: set
Ezsp Config: set broadcast table size to 0x000F:Success: set
Ezsp Config: set neighbor table size to 0x0010:Success: set
NCP supports maxing out packet buffers
Ezsp Config: set packet buffers to 72
Ezsp Config: set end device poll timeout to 0x0008:Success: set
Ezsp Config: set zll group addresses to 0x0000:Success: set
Ezsp Config: set zll rssi threshold to 0xFFD8:Success: set
Ezsp Config: set transient key timeout to 0x00B4:Success: set
Ezsp Endpoint 1 added, profile 0x0104, in clusters: 11, out clusters 23
Ezsp Endpoint 242 added, profile 0xA1E0, in clusters: 0, out clusters 1
HA Gateweay EUI64 = 680AE2FFFE38C006
MQTT Client Init
MQTT Client ID = gw680AE2FFFE38C006
Found 0 files

```
NOTE: You need to reset th MCU manually after flashing, as at the moment this is not handling the RESET pin

Request-Response between PRUSS
==============================

FORMAT:
  Request:
	1-byte: CMD
	arg...

  Response:
	value...

Last three bits are valid for CMD.

	HALT		0
	BLINK		1
	GPIO_OUT	2
	GPIO_IN		3
	SIG_IDLE	4
	SIG_GEN		5
	READ_REG	6
	WRITE_REG	7


HALT(): none
	finish execution of PRU

BLINK(delay, counts, led-bit): none
	Blink LED

SIG_IDLE(count): none
	submit idle(=LOW) for COUNT cycles, strobing SWD-CLK

SIG_GEN(bit-len, data...): none
	submit signal pattern to SWD-DIO, strobing SWD-CLK

READ_REG(cmd): parity-and-ack, value
	execute SWD read register transaction

WRITE_REG(cmd,value): ack
	execute SWD write register transaction

GPIO_OUT(bit, value): none
	control GPIO signal directly, output

GPIO_IN(): value
	control GPIO signal directly, input


Enjoy,
-- 
